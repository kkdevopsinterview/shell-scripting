# Shell Scripting


## **1. What are positional parameters in shell scripting?**

### **Scenario**

You created a deployment script `deploy.sh` that needs environment and version as inputs.

```bash
./deploy.sh dev v1.2
```

### **Explanation**

Positional parameters allow the script to access these inputs:

* `$1` = dev
* `$2` = v1.2

```bash
env=$1
ver=$2
echo "Deploying $env environment with version $ver"
```

### **Interview Explanation**

“In real DevOps pipelines, my scripts take inputs like environment, artifact version, app name. I use positional parameters to access them.”

---

## **2. Difference between $* and $@**

### **Scenario**

A script accepts multiple filenames. You want to loop through each file individually.

### **Explanation**

* `$*` = treats all arguments as **one single string**
* `$@` = treats each argument as **separate**

```bash
for f in "$@"; do
    echo "Processing $f"
done
```

### **Interview**

“I always use `$@` when looping through arguments because each one should be treated separately.”

---

## **3. Read a file line-by-line**

### **Scenario**

You need to read a server list file and ping each server.

### **Example**

```bash
while IFS= read -r server; do
    ping -c1 $server
done < servers.txt
```

### **Interview**

“This pattern avoids breaking lines with spaces and is used a lot in server automation.”

---

## **4. Use of `set -e`**

### **Scenario**

In CI/CD script, if `docker build` fails, next commands should not run.

### **Explanation**

`set -e` stops the script if ANY command fails.

```bash
set -e
docker build -t app .
docker push app   # runs only if build succeeded
```

### **Interview**

“It prevents accidental deployments if earlier steps fail.”

---

## **5. How to define and call functions**

### **Scenario**

You want to reuse a log function across multiple tasks.

```bash
log_msg() { echo "[INFO] $1"; }

log_msg "Deployment started"
```

### **Interview**

“I modularize my scripts with functions for readability and reuse.”

---

## **6. Check if a file exists**

### **Scenario**

Before deleting a backup file, ensure it exists.

```bash
if [ -f "/backup/db.tar" ]; then
    rm /backup/db.tar
fi
```

### **Interview**

“This prevents errors like ‘file not found’ during automation.”

---

## **7. Meaning of $?**

### **Scenario**

You check if a service restart was successful.

```bash
systemctl restart httpd
if [ $? -ne 0 ]; then
    echo "Restart failed"
fi
```

### **Interview**

“I use `$?` to validate command success and handle failures gracefully.”

---

## **8. Check if a variable is empty**

### **Scenario**

User must provide an app name before deployment.

```bash
if [ -z "$APP" ]; then
    echo "APP variable is empty"
fi
```

### **Interview**

“This check avoids running scripts with missing input values.”

---

## **9. What does trap do?**

### **Scenario**

Your script creates a temp directory and should delete it even if user presses `Ctrl+C`.

```bash
trap "rm -rf /tmp/workdir" EXIT
```

### **Interview**

“I use trap for cleanup actions and signal handling.”

---

## **10. Redirect both stdout and stderr**

### **Scenario**

During deployment, you want a single log file containing both errors and normal output.

```bash
deploy.sh > deploy.log 2>&1
```

### **Interview**

“This helps in debugging CI failures because everything is in one place.”

---

## **11. Case statement**

### **Scenario**

A script handles multiple actions: start/stop/status.

```bash
case $1 in
start) systemctl start app;;
stop) systemctl stop app;;
status) systemctl status app;;
*) echo "Invalid option";;
esac
```

### **Interview**

“Case is cleaner than multiple if-else blocks.”

---

## **12. Loop over files in a directory**

### **Scenario**

You want to compress all `.log` files.

```bash
for f in /var/log/*.log; do
    gzip "$f"
done
```

### **Interview**

“I use file loops in log rotation and housekeeping tasks.”

---

## **13. Use of IFS**

### **Scenario**

You have CSV file: `john,30,hyd`

```bash
IFS=',' read -r name age city <<< "john,30,hyd"
```

### **Interview**

“IFS helps me process CSV files and split values correctly.”

---

## **14. Use of shift**

### **Scenario**

Script takes unlimited arguments; you process them one by one.

```bash
while [ "$1" ]; do
    echo "Arg: $1"
    shift
done
```

### **Interview**

“I use shift in advanced scripts to iterate through parameters.”

---

## **15. Purpose of exec**

### **Scenario**

Redirect entire script output to a log file.

```bash
exec > script.log 2>&1
```

### **Interview**

“This is helpful in cron jobs where I need complete logging.”

---

## **16. Difference: `source script.sh` vs `./script.sh`**

### **Scenario**

You set environment variables in `setenv.sh`.

* `source setenv.sh` → variables available in same shell
* `./setenv.sh` → variables NOT available

### **Interview**

“For loading env vars permanently, I always use `source`.”

---

## **17. How to pass arguments to a script**

### **Scenario**

```bash
./backup.sh /var/www daily
```

Inside script:

```bash
path=$1
type=$2
```

### **Interview**

“My automation scripts always accept parameters instead of hard-coded values.”

---

## **18. Exit a script with a status code**

### **Scenario**

Exit if DB connection fails.

```bash
if ! mysql -u root -p; then
    echo "DB connection failed"
    exit 1
fi
```

### **Interview**

“I use exit codes so monitoring tools know if script succeeded.”

---

## **19. Perform arithmetic**

### **Scenario**

Calculate disk usage percentage.

```bash
used=40
total=100
perc=$(( (used * 100) / total ))
```

### **Interview**

“I use $(( )) for arithmetic in monitoring scripts.”

---

## **20. Compare strings**

### **Scenario**

Check if environment is prod:

```bash
if [ "$env" = "prod" ]; then
    echo "Deploying to production"
fi
```

### **Interview**

“I always quote strings to avoid errors with spaces.”
